# Open Lavatory Protocol - Cursor AI Rules

## Project Overview
This is the **Open Lavatory Protocol** - a decentralized, privacy-first alternative to WalletConnect v2 that eliminates centralized relay servers. The protocol enables secure P2P connections between dApps and wallets using public signaling servers (MQTT/Waku/Nostr) for initial handshake, then direct WebRTC for ongoing communication.

## Architecture & Key Components

### Project Structure
```
packages/
├── lib/                    # Core protocol implementation
│   ├── src/
│   │   ├── connection.ts   # Main OpenLVConnection class
│   │   ├── types.ts        # TypeScript type definitions
│   │   ├── signaling/      # MQTT/Waku/Nostr signaling
│   │   └── utils/          # Encryption utilities
│   └── package.json
├── sandbox/                # Demo application
│   ├── src/App.tsx        # React demo UI
│   └── package.json
└── provider/              # EIP-6963 wallet provider
```

### Core Protocol Flow
1. **Discovery**: dApp generates session + ECDH keypair, creates `openlv://` URL
2. **Pairing**: Wallet scans URL, connects via MQTT, exchanges public keys
3. **WebRTC**: Peers establish direct P2P connection with encrypted handshake
4. **Communication**: JSON-RPC 2.0 messages over WebRTC DataChannel

## Critical Technical Learnings

### WebRTC Message Handling Anti-Pattern
**NEVER** treat JSON-RPC responses as requests! The data channel handler must distinguish:
```typescript
// ✅ CORRECT: Check if message is request vs response
if ('method' in message) {
    // Handle JSON-RPC request
    const request = message as JsonRpcRequest;
    // Process and send ONE response
} else {
    // Handle JSON-RPC response - just log, don't process
    const response = message as JsonRpcResponse;
}
```

**❌ WRONG**: Processing all messages as requests creates infinite feedback loops.

### Encryption Scheme Evolution
- **Phase 1**: Shared symmetric keys (vulnerable to MITM)
- **Phase 2**: ECDH P-256 with ECIES encryption (current implementation)
- **Phase 3**: Dual-phase encryption (symmetric handshake → asymmetric communication)

### Connection State Management
States: `disconnected` → `mqtt-connecting` → `pairing` → `key-exchange` → `webrtc-negotiating` → `webrtc-connected`

**Key principle**: MQTT closes when WebRTC connects (saves bandwidth), reopens on WebRTC failure (automatic fallback).

### ICE Candidate Decryption Issue
**Problem**: Peers receive their own ICE candidates via MQTT broadcast, causing decryption failures when trying to decrypt with wrong key.
**Solution**: Proper message filtering by `senderId` to ignore own messages.

## Development Workflows

### Building & Linting
```bash
# Fix all linting issues across project
pnpm lint:fix

# Build the lib package
cd packages/lib && pnpm build

# Run sandbox demo
cd packages/sandbox && pnpm dev
```

### Common Issues & Solutions

#### 1. Import Path Issues
- Always use `.js` extensions in imports for ESM compatibility
- Example: `import { EncryptionUtils } from './utils/encryption.js'`

#### 2. WebRTC Connection Problems
- Firefox requires TURN servers, Chrome works with STUN only
- Check browser compatibility in logs
- Use connection retry mechanism with exponential backoff

#### 3. Message Spam/Loops
- Usually caused by treating responses as requests
- Check data channel message handler logic
- Verify `senderId` filtering to ignore own messages

#### 4. Encryption Errors
- "key is not extractable" → Don't export imported keys, compute hash from raw data
- "Failed to decrypt message" → Check if peer is trying to decrypt own message
- Use `computePublicKeyHashFromRaw()` for verification before key import

## URL Format & Parameters
```
openlv://<session-id>?h=<pubkey-hash>&k=<shared-key>&s=<server>&p=<protocol>
```
- `h`: First 8 bytes of SHA-256 hash of public key (base64)
- `k`: Shared secret for symmetric encryption during handshake
- `s`: MQTT server URL (optional, defaults to test.mosquitto.org)
- `p`: Protocol type (mqtt/waku/nostr, defaults to mqtt)

## JSON-RPC Integration
- All communication uses JSON-RPC 2.0 format
- Custom method `lv_rawText` for plain text messages
- Proper request/response handling with unique IDs
- Error responses with standard error codes

## Testing & Debugging
- Enable debug mode in sandbox for detailed logs
- Monitor WebRTC connection states and ICE gathering
- Check MQTT message flow and encryption/decryption
- Verify public key hash matching during handshake

## Security Considerations
- ECDH P-256 curve for key exchange
- AES-256-GCM for message encryption
- ECIES scheme with ephemeral keys
- SHA-256 for public key hashing
- No plaintext transmission after initial URL sharing

## Browser Compatibility
- Chrome/Chromium: Full support with STUN servers
- Firefox: Requires TURN servers for WebRTC
- Safari: Not extensively tested
- Mobile browsers: Should work but may need additional TURN servers

## Future Enhancements
- Waku protocol integration for decentralized signaling
- Nostr protocol support
- Multi-wallet connection support
- Enhanced error recovery mechanisms
- Performance optimizations for mobile devices

## Common Commands Reference
```bash
# Development
pnpm install          # Install all dependencies
pnpm lint:fix         # Fix linting issues
pnpm build            # Build lib package
pnpm dev              # Start sandbox demo

# Debugging
pnpm lint             # Check linting issues
pnpm type-check       # TypeScript type checking
```

Remember: This protocol prioritizes **privacy** and **decentralization** over convenience. Every design decision should eliminate single points of failure and minimize data exposure to third parties. 